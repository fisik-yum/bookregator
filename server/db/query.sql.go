// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package db

import (
	"context"
)

const getISBNRoute = `-- name: GetISBNRoute :one
;

SELECT COUNT(*) FROM isbns WHERE isbn = 1 LIMIT 1
`

func (q *Queries) GetISBNRoute(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getISBNRoute)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getNReviewsByOLID = `-- name: GetNReviewsByOLID :many
SELECT review_id, olid, source, external_id, username, rating, text FROM reviews WHERE olid = ? ORDER BY RANDOM() LIMIT ?
`

type GetNReviewsByOLIDParams struct {
	Olid  string `json:"olid"`
	Limit int64  `json:"limit"`
}

func (q *Queries) GetNReviewsByOLID(ctx context.Context, arg GetNReviewsByOLIDParams) ([]Review, error) {
	rows, err := q.db.QueryContext(ctx, getNReviewsByOLID, arg.Olid, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Review
	for rows.Next() {
		var i Review
		if err := rows.Scan(
			&i.ReviewID,
			&i.Olid,
			&i.Source,
			&i.ExternalID,
			&i.Username,
			&i.Rating,
			&i.Text,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOLIDFromISBN = `-- name: GetOLIDFromISBN :one
SELECT olid FROM isbns WHERE isbn = ? LIMIT 1
`

func (q *Queries) GetOLIDFromISBN(ctx context.Context, isbn string) (string, error) {
	row := q.db.QueryRowContext(ctx, getOLIDFromISBN, isbn)
	var olid string
	err := row.Scan(&olid)
	return olid, err
}

const getRandomWork = `-- name: GetRandomWork :one
SELECT olid FROM works ORDER BY RANDOM() LIMIT 1
`

func (q *Queries) GetRandomWork(ctx context.Context) (string, error) {
	row := q.db.QueryRowContext(ctx, getRandomWork)
	var olid string
	err := row.Scan(&olid)
	return olid, err
}

const getStats = `-- name: GetStats :one
SELECT olid, review_count, avg_rating, med_rating, ci_bound FROM stats WHERE olid = ? LIMIT 1
`

func (q *Queries) GetStats(ctx context.Context, olid string) (Stat, error) {
	row := q.db.QueryRowContext(ctx, getStats, olid)
	var i Stat
	err := row.Scan(
		&i.Olid,
		&i.ReviewCount,
		&i.AvgRating,
		&i.MedRating,
		&i.CiBound,
	)
	return i, err
}

const getWorkByOLID = `-- name: GetWorkByOLID :one
SELECT olid, title, author, cover, description FROM works WHERE olid = ? LIMIT 1
`

func (q *Queries) GetWorkByOLID(ctx context.Context, olid string) (Work, error) {
	row := q.db.QueryRowContext(ctx, getWorkByOLID, olid)
	var i Work
	err := row.Scan(
		&i.Olid,
		&i.Title,
		&i.Author,
		&i.Cover,
		&i.Description,
	)
	return i, err
}

const insertISBN = `-- name: InsertISBN :exec
INSERT INTO isbns (isbn, olid) VALUES (?, ?)
`

type InsertISBNParams struct {
	Isbn string `json:"isbn"`
	Olid string `json:"olid"`
}

func (q *Queries) InsertISBN(ctx context.Context, arg InsertISBNParams) error {
	_, err := q.db.ExecContext(ctx, insertISBN, arg.Isbn, arg.Olid)
	return err
}

const insertReview = `-- name: InsertReview :exec
INSERT INTO reviews ( olid, source, external_id, username, rating, text) values (?, ?, ?, ?, ?, ?)
`

type InsertReviewParams struct {
	Olid       string  `json:"olid"`
	Source     string  `json:"source"`
	ExternalID string  `json:"external_id"`
	Username   string  `json:"username"`
	Rating     float64 `json:"rating"`
	Text       *string `json:"text"`
}

func (q *Queries) InsertReview(ctx context.Context, arg InsertReviewParams) error {
	_, err := q.db.ExecContext(ctx, insertReview,
		arg.Olid,
		arg.Source,
		arg.ExternalID,
		arg.Username,
		arg.Rating,
		arg.Text,
	)
	return err
}

const insertStat = `-- name: InsertStat :exec
INSERT  INTO stats (olid, review_count, avg_rating, med_rating, ci_bound) VALUES (?, ?, ?, ?, ?)
ON CONFLICT(olid) DO UPDATE SET review_count=excluded.review_count, avg_rating=excluded.avg_rating, med_rating=excluded.med_rating, ci_bound=excluded.ci_bound
`

type InsertStatParams struct {
	Olid        string  `json:"olid"`
	ReviewCount int64   `json:"review_count"`
	AvgRating   float64 `json:"avg_rating"`
	MedRating   float64 `json:"med_rating"`
	CiBound     float64 `json:"ci_bound"`
}

func (q *Queries) InsertStat(ctx context.Context, arg InsertStatParams) error {
	_, err := q.db.ExecContext(ctx, insertStat,
		arg.Olid,
		arg.ReviewCount,
		arg.AvgRating,
		arg.MedRating,
		arg.CiBound,
	)
	return err
}

const insertWork = `-- name: InsertWork :exec
INSERT INTO works (olid, title, cover,author, description) values (?, ?, ?, ?, ?)
`

type InsertWorkParams struct {
	Olid        string  `json:"olid"`
	Title       string  `json:"title"`
	Cover       *string `json:"cover"`
	Author      *string `json:"author"`
	Description *string `json:"description"`
}

func (q *Queries) InsertWork(ctx context.Context, arg InsertWorkParams) error {
	_, err := q.db.ExecContext(ctx, insertWork,
		arg.Olid,
		arg.Title,
		arg.Cover,
		arg.Author,
		arg.Description,
	)
	return err
}

const rawStatsFromTable = `-- name: RawStatsFromTable :many
SELECT
    rating
FROM reviews
WHERE
    olid = ?1 AND rating != -1
`

func (q *Queries) RawStatsFromTable(ctx context.Context, olid string) ([]float64, error) {
	rows, err := q.db.QueryContext(ctx, rawStatsFromTable, olid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []float64
	for rows.Next() {
		var rating float64
		if err := rows.Scan(&rating); err != nil {
			return nil, err
		}
		items = append(items, rating)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
